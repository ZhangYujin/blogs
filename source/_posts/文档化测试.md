---
title: 文档化测试
date: 2017-10-28 11:50:19
tags: 
- 测试
categories:
- 编程
- 翻译
- 测试
---
[原文链接][1]
文档需要够全面、能实时更新而且还易于理解。对于全面，我的意思是它能够包含代码中所有重要的部分以及应用程序中的所有函数。虽然文档化的重要性在多数情况下是显而易见的，但是许多使它保持准备和实时更新的尝试却没能成功。对文档缺失的治理需要更多的资源以及更多的时间，往往文档还因为错误的原因而产生。
### 要求文档化的原因
要求文档化的原因有很多。团队通常是由于政治方面的原因或者纯粹的无知而要求文档化。一些创建文档的错误原因是：
- 有些人认为一些文档跟项目的成功有联系
- 文档证明了某些人的存在
- 要求者不知道有什么更好的做法
- 请求者想要自我安慰：一切尽在掌握之中
- 流程要求要建立文档

### 文档没有实时更新
软件文档最主要的问题是它大多数时候没有及时的更新。当有些代码发生改变，文档没能反映实际的情况。这声明对任何需求的文档都凑效而且测试用例受到的影响最大。不管我们有多努力，文档化不可避免地过时了。
### 谁在使用文档
这需要根据用户、需要的文档类型和不同的格式而确定。开发者、测试人员、消费者、管理人员、终端用户可能是文档潜在的最主要用户。
#### 开发者
开发者不应该依赖于系统文档，因为它多数情况下都没有及时更新。而且，没有什么文档能够像代码本身那样有详细且最新的描述。想知道一个方法是干嘛的，直接看方法代码就行了。不确定一些类是做什么的，直接看类的代码。需要文档常常说明了代码本身没有很好的编写。
代码即文档并不是排斥其他类型的文档，关键是要避免重复。如果通过阅读代码能够获取系统的细节，其他类型的文档能够提供快速的参考和高水平的概述。非代码型文档应该回答像系统的主要用途是什么和系统中用了什么样的技术这样的问题。在许多情况下，README.md文档就能够开发者快速入门的需要了。像项目描述、环境搭建、安装、编译和打包说明这样的章节就对新入门的菜鸟很有帮助。接下来，代码才是权威了。产品的代码提供了所有需要的细节，测试代码能够描述产品代码背后的意图。测试驱动开发是创建和管理可执行文档最普遍的方式。
假设某种形式的持续集成在被使用，如果测试文档的一些部分不正确，它就会执行失败然后被修复。CI能够修复不正确的测试文档的问题，但是不能确定所有的功能都被文档化。就为了这个原因（还有其他的）测试文档应该要以TDD的形式创建。如果所有的功能都能够在实现之前被定义成测试并且所有测试的执行都能够成功，那么测试就能够以完整且最新的文档为开发者所用。
那我们该对团队中其他类型的人该怎么做呢？测试人员、顾客、管理者和其他的非编程人员无法从产品和测试代码中获取需要的信息。
#### 测试人员
最普遍的两种测试类型是黑盒测试和白盒测试。这种划分很重要，它也同时将测试人员划分为懂得写代码或者起码能读代码的测试人员（白盒测试）和不懂代码的测试人员（黑盒测试）。在一些情况下测试人员可能同属于这两种类型。但往往测试人员不懂得如何写代码，因此对开发者有用的文档对他们却没有用。如果文档要跟代码解耦，那么单元测试就不太适用了。这就是行为驱动开发出现的其中一个原因。它能够提供必要的文档给非开发人员，但仍能保持测试驱动开发和自动化的优势。
#### 客户
客户需要能够给系统定义新的功能，同时还要能够获取到现有系统中所有重要的部分的信息。那种文档就不能够太技术化（代码就派不上用场了）但却能够始终保持更新。行为驱动开发的叙述和情景描述是提供这种类型文档最好的方式。作为可接受条件（在代码开发前编写）被频繁地执行（最好是在每次提交）并且用自然语言进行编写使得行为驱动开发不紧能够实时更新而且能够被那些不关注代码的人使用。
#### 可执行的文档
文档是软件的一部分。如软件的其他部分，它也需要经常性的测试我们才能确定它是正确而且是保持最新的。能够完成这个工作仅有的有效方式是将可执行文档整合到你那持续整合的系统中。测试驱动开发方法论是推动这个方向最好的方式。在低一个层次，单元测试也很合适。另一方面，行为驱动开发作用于功能层面上提供了一个很好的方式，同时使用自然语言来完成理解。



[1]: http://technologyconversations.com/2014/04/08/tests-as-documentation/    "文档化测试"